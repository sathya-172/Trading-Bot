// Import protobufjs (make sure you've installed it: npm install protobufjs)
const protobuf = require('protobufjs');

const SubscriptionModes = Object.freeze({
    DEPTH: 'depth',
  });

class Depth {
  constructor() {
    this.tbq = 0;
    this.tsq = 0;
    this.bidprice = new Array(50).fill(0.0);
    this.askprice = new Array(50).fill(0.0);
    this.bidqty = new Array(50).fill(0);
    this.askqty = new Array(50).fill(0);
    this.bidordn = new Array(50).fill(0);
    this.askordn = new Array(50).fill(0);
    this.snapshot = false;
    this.timestamp = 0;
    this.sendtime = 0;
    this.seqNo = 0;
  }

  toString() {
    return `Depth{ts: ${this.timestamp}, send_ts: ${this.sendtime}, tbq: ${this.tbq}, tsq: ${this.tsq}, ` +
      `bidprice: ${this.bidprice}, askprice: ${this.askprice}, ` +
      `bidqty: ${this.bidqty}, askqty: ${this.askqty}, ` +
      `bidordn: ${this.bidordn}, askordn: ${this.askordn}, ` +
      `snapshot: ${this.snapshot}, sNo: ${this.seqNo} }`;
  }

  /**
   * Adds depth data from a protobuf message.
   * @param {Object} currdata - The protobuf message.
   * @param {boolean} isSnapshot - Whether this is a snapshot.
   */
  _addDepth(currdata, isSnapshot) {
    // Check if the 'depth' field exists.
    if (currdata.depth != null) {
      this.snapshot = isSnapshot;

      // Using wrapper types, so the values are in the `value` property.
      if (currdata.depth.tbq != null) {
        this.tbq = currdata.depth.tbq.value / 1;
      }

      if (currdata.depth.tsq != null) {
        this.tsq = currdata.depth.tsq.value / 1;
      }

      // Process asks if present.
      if (Array.isArray(currdata.depth.asks)) {
        currdata.depth.asks.forEach((ask, i) => {
          if (ask.price != null) {
            this.askprice[i] = ask.price.value / 100;
          }
          if (ask.qty != null) {
            this.askqty[i] = ask.qty.value;
          }
          if (ask.nord != null) {
            this.askordn[i] = ask.nord.value;
          }
        });
      }

      // Process bids if present.
      if (Array.isArray(currdata.depth.bids)) {
        currdata.depth.bids.forEach((bid, i) => {
          if (bid.price != null) {
            this.bidprice[i] = bid.price.value / 100;
          }
          if (bid.qty != null) {
            this.bidqty[i] = bid.qty.value;
          }
          if (bid.nord != null) {
            this.bidordn[i] = bid.nord.value;
          }
        });
      }

      // Process other fields (assuming wrapper types)
      if (currdata.feedTime != null ) {
        this.timestamp = currdata.feedTime.value / 1;
      }
      if (currdata.sendTime != null ) {
        this.sendtime = currdata.sendTime.value / 1;
      }
    this.seqNo = currdata.sequenceNo / 1;  
    }
  }
}

class SubscriptionInfo {
    constructor() {
        this._symbols = {}; // Stores channel-wise symbol sets
        this._modeInfo = {}; // Stores channel-wise subscription modes
        this._activeChannels = new Set(); // Stores active channels
    }

    subscribe(symbols, channelNo, mode) {
        if (this._symbols[channelNo]) {
            this._symbols[channelNo] = new Set([...this._symbols[channelNo], ...symbols]);
        } else {
            this._symbols[channelNo] = new Set(symbols);
        }
        this._modeInfo[channelNo] = mode;
    }

    unsubscribe(symbols, channelNo) {
        if (this._symbols[channelNo]) {
            symbols.forEach(symbol => this._symbols[channelNo].delete(symbol));
            if (this._symbols[channelNo].size === 0) {
                delete this._symbols[channelNo];
            }
        }
    }

    updateChannels(pauseChannels, resumeChannels) {
        pauseChannels.forEach(channel => this._activeChannels.delete(channel));
        resumeChannels.forEach(channel => this._activeChannels.add(channel));
    }

    updateMode(modeConfig) {
        Object.entries(modeConfig).forEach(([channelNo, mode]) => {
            this._modeInfo[channelNo] = mode;
        });
    }

    getSymbolsInfo(channelNo) {
        return this._symbols[channelNo] || new Set();
    }

    getModeInfo(channelNo) {
        return this._modeInfo[channelNo] || null;
    }

    getChannelInfo() {
        return this._activeChannels;
    }
}

class DataStore {
    constructor() {
        this.depth = {}; // Stores depth data by symbol
    }

    updateDepth(packet, cb, diffOnly) {
        if (packet.feeds) {
            Object.entries(packet.feeds).forEach(([_, value]) => {
                const symbol = value.ticker;

                if (!this.depth[symbol]) {
                    this.depth[symbol] = new Depth();
                }

                if (!diffOnly) {
                    this.depth[symbol]._addDepth(value, packet.snapshot);
                    if (cb) cb(symbol, this.depth[symbol]);
                } else {
                    const depth = new Depth();
                    depth._addDepth(value, packet.snapshot);
                    if (cb) cb(symbol, depth);
                }
            });
        }
    }
}

module.exports.DataStore = DataStore;
module.exports.SubscriptionInfo = SubscriptionInfo;
module.exports.Depth = Depth;
module.exports.SubscriptionModes = SubscriptionModes;
