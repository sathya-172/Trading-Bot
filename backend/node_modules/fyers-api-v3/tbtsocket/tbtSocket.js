const WebSocket = require('ws');
let Logger = require("../logger/log.js")
let { Config } = require("../config/config.js");
let {DataStore, Depth, SubscriptionModes, SubscriptionInfo} = require('./models.js')
let {SocketMessage} = require('./msg.js') 
const axios = require('axios');
var reconnectiontries = 0

function getUrl(accessToken) {
    try {
        const response = https.get('https://api-t1.fyers.in/indus/home/tbtws', {
            headers: {
                'Authorization': accessToken
            }
        }, (res) => {
            let data = '';
            res.on('data', chunk => {
                data += chunk;
            });
            res.on('end', () => {
                try {
                    const jsonData = JSON.parse(data);
                    return jsonData.data.socket_url;
                } catch (error) {
                    console.error('Error parsing response:', error);
                }
            });
        });
    } catch (error) {
        console.error('Error fetching URL:', error);
    }
    return "wss://rtsocket-api.fyers.in/versova";
}

/**
 * Class to access order update websocket.
 * @class
 */
class FyersTbtSocket {

    constructor(authorizationKey, logpath = undefined ,loggingFlag=true, diffOnly=false) {
        this.url = getUrl(authorizationKey);
        this.authorizationKey = authorizationKey;
        this.ws = null;
        this.onErrorCallback = null;
        this.LogPath = logpath;
        this.Logger = new Logger(this.LogPath,loggingFlag);
        this.isPingEnabled = true;
        this.pingInterval = null;
        this.autoreconnectinterval = null;
        this.isUserClosed=false
        this.autoreconnectflag=false
        this.maxreconnectiontries = 0
        this.datastore = new DataStore()
        this.subsinfo = new SubscriptionInfo()
        this.onDepthCallback = null;
        this.onErrorMsgCallback = null;
        this.diffOnly = diffOnly
    }

    /**
     * called to connect to the order socket
     */
    connect() {
        const logger = this.Logger
        try {
            logger.debug("initalizing connection to socket", { "accesstoken": this.authorizationKey })
            this.ws = new WebSocket(this.url, {
                headers: {
                    Authorization: this.authorizationKey,
                },
            });
            this.ws.binaryType = 'arraybuffer';
            this.ws.on('error', (error) => {
                if (this.onErrorCallback) {
                    this.onErrorCallback(error);
                }
                else {
                    console.log("error occoured", error)
                }
            });

            this.ws.on('close', (event) => {
                this.stopPing()
                if (this.onCloseCallback) {
                    this.onCloseCallback(event);
                }
                else {
                    console.log("ws closed", event)
                    if(!this.isUserClosed&&(reconnectiontries<this.maxreconnectiontries)){
                        this._autoreconnect()
                    }
                }
            });

            this.ws.on('message', (message) => {
                const data = message.toString();
                if (data === 'pong') {
                    return
                }
                else {
                    const m = SocketMessage.decode(Buffer.from(message));
                    if (m.error) {
                        if (this.onErrorMsgCallback) {
                            this.onErrorMsgCallback(m.msg);
                        }
                        else {
                            console.log("error occoured", m.error)
                        }
                    } else {
                        this.datastore.updateDepth(m, this.onDepthCallback, this.diffOnly)
                    }
                }
            });

            this.ws.on('open', () => {
                reconnectiontries = 0
                if (this.onOpenCallback) {
                    this.onOpenCallback();
                    let open_chans = this.subsinfo.getChannelInfo()
                    this.switchChannel(new Set(), open_chans)
                    for (var c in open_chans) {
                        let symbols = this.subsinfo.getSymbolsInfo(c)
                        let mode = this.subsinfo.getModeInfo(c)
                        this.subscribe(symbols, c, mode)
                    }
                }
                else {
                    console.log("connected")
                }

                if (this.isPingEnabled) {
                    this.startPing();
                }
            });
        }
        catch (error) {
            console.log(`Error occured: ${error}`)
            logger.error("unexpected error on connect function", error)
        }
    }

    /**
     * used to define onmessage,onerror,onopen,onclose for websocket.
     * @param {string} onwhat - defines for what the callback function is.
     * @param {Function} callback - the callback function.
     * @throws  error message if onwhat is not valid.
     */
    on(onwhat, callback) {
        const funcname = "on"
        const logger = this.Logger
        try {
            if (onwhat === 'error') {
                this.onErrorCallback = callback;
            }
            else if (onwhat === 'depth') {
                this.onDepthCallback = callback;
            }
            else if (onwhat === 'servererror') {
                this.onErrorMsgCallback = callback;
            }
            else if (onwhat === 'close') {
                const socketonclose = function (event){
                    callback(event)
                    if(!this.isUserClosed&&(reconnectiontries<this.maxreconnectiontries)){
                        this._autoreconnect()
                    }
                }
                this.onCloseCallback = socketonclose;
            }
            else if (onwhat === 'open') {
                this.onOpenCallback = callback;
            } 
            else {
                console.log("incorrect value passed", onwhat, "allowed values are: error, depth, servererror, close and open")
                logger.error("wrong onwhat passed", { "onwhat": onwhat }, funcname)
            }
        }
        catch (error) {
            logger.error("unexpected error on 'on' function", error, funcname)
        }
    }

    /**
     * call to check if datasocket is connected
     */
    isConnected() {
        return this.ws && this.ws.readyState === WebSocket.OPEN;
    }

    /**
     * starts ping messages to ws
     */
    startPing() {
        this.pingInterval = setInterval(() => {
            if (this.isConnected()) {
                this.ws.send("ping");
            }
        }, 1000);
    }

    /**
     * stops pinging mechanism
     */
    stopPing() {
        clearInterval(this.pingInterval);
    }

    /**
     * Subscribe to socket.
     * @param {Array|string} towhat - array or string of what you want to subscribe to.
     */
    subscribe(symbolTickers, channelNo, mode) {
        const logger = this.Logger
        try {
            if (this.isConnected()) {

                this.subsinfo.subscribe(symbolTickers, channelNo, mode);
                this.ws.send(JSON.stringify({
                    "type": 1,
                    "data": {
                        "subs": 1,
                        "symbols": Array.from(symbolTickers), // Convert Set to array
                        "mode": mode,
                        "channel": channelNo
                    }
                }));
            }
            else {
                logger.error("websocket is not connected", { "towhat": towhat },)
                console.log('Cannot send message. WebSocket is not connected.');
            }
        }
        catch (error) {

            logger.error("unexpected error on subscribe function", error,)
        }
    }

    /**
     * Unsubscribe to socket.
     * @param {Array|string} towhat - array or string of what you want to unsubscribe to.
     */
    unsubscribe(symbolTickers, channelNo, mode) {
        const logger = this.Logger
        try {
            if (this.isConnected()) {
                this.subsinfo.subscribe(symbolTickers, channelNo, mode);
                this.ws.send(JSON.stringify({
                    "type": 1,
                    "data": {
                        "subs": -1,
                        "symbols": Array.from(symbolTickers), // Convert Set to array
                        "mode": mode,
                        "channel": channelNo
                    }
                }));
            }
            else {
                logger.error("websocket is not connected", { "towhat": towhat }, )
                console.log('Cannot send message. WebSocket is not connected.');
            }
        }
        catch (error) {

            logger.error("unexpected error on unsubscribe function", error, )
        }
    }

    switchChannel(pausedChannels, resumedChannels) {
        const logger = this.Logger
        try {
            if (this.isConnected()) {
                this.subsinfo.updateChannels(pausedChannels, resumedChannels);
                this.ws.send(JSON.stringify(
                    {
                        "type": 2,
                        "data": {
                            "resumeChannels": Array.from(resumedChannels),
                            "pauseChannels": Array.from(pausedChannels)
                        }
                    }
                ));
            }
            else {
                logger.error("websocket is not connected", { "towhat": towhat }, )
                console.log('Cannot send message. WebSocket is not connected.');
            }
        }
        catch (error) {

            logger.error("unexpected error on switchchannel function", error)
        }
    }

    /**
     * call to close the datasocket.
     */
    close() {
        if (this.ws && this.isConnected) {
            clearInterval(this.autoreconnectinterval)
            this.stopPing()
            this.ws.close();
            this.isUserClosed = true
        }
    }

    /**
     * call to enable autoreconnect functionality of websocket.
     */
    _autoreconnect() {
        if (this.autoreconnectflag){
            var waitSeconds = Math.floor((reconnectiontries+5)/5);
            waitSeconds *= 5;

            this.autoreconnectinterval = setTimeout(() => {
                if ((!this.isConnected()) && (reconnectiontries < this.maxreconnectiontries)) {
                    console.log("trying to reconnect ", reconnectiontries + 1)
                    reconnectiontries++
                    this.connect()
                } else if (reconnectiontries >= this.maxreconnectiontries) {
                    console.log("max autoconnect tries exceeded")
                    clearInterval(this.autoreconnectinterval)
                    this.stopPing()
                    reconnectiontries = 0
                }
            },  (waitSeconds)*1000);
        }
    }
    /**
     * call to enable autoreconnect functionality of websocket.
     */
    autoreconnect(reConnectTriesCount=5){
        this.autoreconnectflag=true
        this.maxreconnectiontries=(reConnectTriesCount>50) ? 50 : reConnectTriesCount
    }
}

module.exports = FyersTbtSocket